/*******************************************************
 * ESP32-C3 mini + Qingping Barometer (CGP23W) (BLE → MQTT HA)
 *
 * Features:
 * - NimBLE scanning (UUID=0xFDCD)
 * - Parse Temperature / Humidity / Battery / Pressure (kPa) + RSSI
 * - Publish to Home Assistant via MQTT every 5 seconds (Autodiscovery)
 * - 【Diagnostic】Boot Count / LAN IP / MAC / MQTT Errors /
 *                 Reset Reason / WAN IP / Wi-Fi BSSID / Wi-Fi Channel /
 *                 Wi-Fi Reconnects / Wi-Fi RSSI Proxy / Wi-Fi SSID / Uptime
 * - 【Controls】Restart Button (MQTT)
 * - 【Controls】On-board LED Switch (MQTT, default OFF, reset OFF, HA initial sync OFF)
 * - 【Startup】LED blinks 3 times (200ms ON/OFF)
 *
 * Requirements:
 * - NimBLE-Arduino v2.3.4
 * - PubSubClient v2.8
 * - ArduinoJson v7.4.2
 *******************************************************/
#include <Arduino.h>
#include <WiFi.h>
#define MQTT_MAX_PACKET_SIZE 2048
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <NimBLEDevice.h>
#include <vector>
#include <Preferences.h>
#include <HTTPClient.h>
#include <esp_system.h>

/* ===================【 LED Pin Definition 】=================== */
static const int LED_PIN = 8;   // ESP32-C3 built-in LED
static bool ledState = false;   // Default OFF
/* ===================【 MQTT Sensor Definition 】=================== */
struct SensorConfig {
  const char* id;
  const char* name;
  const char* icon;
  const char* unit;
  const char* devclass;
  const char* stateclass;
  const char* category;
};

const SensorConfig sensors[] = {
  {"temperature","Temperature","mdi:thermometer","°C","temperature","measurement",nullptr},
  {"humidity",   "Humidity","mdi:water-percent","%","humidity","measurement",nullptr},
  {"battery",    "Battery","mdi:battery","%","battery","measurement","diagnostic"},
  {"pressure",   "Pressure","mdi:gauge","kPa","pressure","measurement",nullptr},
  {"rssi",       "BLE RSSI","mdi:signal","dBm","signal_strength","measurement","diagnostic"},
  // Diagnostic
  {"boot_count","Boot Count","mdi:counter","","","total_increasing","diagnostic"},
  {"ip","LAN IP","mdi:ip","","","","diagnostic"},
  {"mac","MAC Address","mdi:network","","","","diagnostic"},
  {"mqtt_errors","MQTT Errors","mdi:home-alert","","","total_increasing","diagnostic"},
  {"reset_reason","Reset Reason","mdi:restart-alert","","","","diagnostic"},
  {"wan_ip","WAN IP","mdi:web","","","","diagnostic"},
  {"wifi_bssid","Wi-Fi BSSID","mdi:access-point","","","","diagnostic"},
  {"wifi_channel","Wi-Fi Channel","mdi:wifi-settings","","","","diagnostic"},
  {"wifi_reconnects","Wi-Fi Reconnects","mdi:wifi-off","","","total_increasing","diagnostic"},
  {"rssi_proxy","Wi-Fi RSSI Proxy","mdi:wifi-strength-2","dBm","signal_strength","measurement","diagnostic"},
  {"wifi_ssid","Wi-Fi SSID","mdi:wifi","","","","diagnostic"},
  {"uptime","Uptime","mdi:clock-outline","s","duration","measurement","diagnostic"}
};
/* ===================【 WiFi and MQTT (Safe Placeholders) 】=================== */
const char* ssid        = "YOUR_WIFI_SSID";
const char* password    = "YOUR_WIFI_PASSWORD";
const char* mqtt_server = "YOUR_MQTT_SERVER";
const int   mqtt_port   = 1883;               // Default MQTT port
const char* mqtt_user   = "YOUR_MQTT_USER";
const char* mqtt_pass   = "YOUR_MQTT_PASSWORD";

const char* discovery_prefix   = "homeassistant";
const char* topic_prefix       = "ESP32_C3_EXAMPLE";
const char* AVAIL_TOPIC        = "ESP32_C3_EXAMPLE/availability";
const char* CMD_RESTART_TOPIC  = "ESP32_C3_EXAMPLE/cmd/restart";
const char* CMD_LED_TOPIC      = "ESP32_C3_EXAMPLE/cmd/led";   // LED control
const char* STATE_LED_TOPIC    = "ESP32_C3_EXAMPLE/state/led"; // LED state

/* ===================【 HA Device Information (Safe Placeholders) 】=================== */
const char* DEVICE_ID   = "ESP32_C3_EXAMPLE";
const char* DEVICE_NAME = "ESP32-C3 Example Device";
const char* DEVICE_MODEL= "ESP32-C3-MINI";
const char* DEVICE_MANUFACTURER = "DIY Developer";
const char* HW_VERSION  = "ESP32_C3_EXAMPLE_HW (v1.0.0)";
const char* SW_VERSION  = "ESP32_C3_EXAMPLE_SW (v1.0.0)";

/* ===================【 Publish Interval 】=================== */
#define PUBLISH_INTERVAL_MS 5000

/* ===================【 State Variables 】=================== */
static uint32_t bootCount=0, wifiReconnects=0, mqttErrors=0;
static char wan_ip[40] = "N/A";
static volatile bool g_needRestart=false;
static uint32_t lastWanFetch=0;
WiFiClient   net;
PubSubClient client(net);
Preferences  prefs;

/* ===================【 BLE Target and Data Structure 】=================== */
static const char* TARGET_BLE_ADDR = "aa:bb:cc:dd:ee:ff";   // Example BLE MAC

struct QingpingParsed {
  float temperature_c;
  float humidity_rh;
  int   battery_pct;
  float pressure_kpa;
  int   rssi_dbm;
};
static QingpingParsed g_last{};
static bool g_haveData = false;

/* ===================【 WAN IP / Helper Functions 】=================== */
static String resetReasonStr(){
  switch(esp_reset_reason()){
    case ESP_RST_POWERON:return "Power-On";
    case ESP_RST_SW:return "Software";
    case ESP_RST_PANIC:return "Exception";
    default:return "Other";
  }
}
static bool fetchWANIPOnce(const char*url){
  HTTPClient http; if(!http.begin(url)) return false;
  int code=http.GET();
  if(code==200){String s=http.getString();s.trim();
    if(s.length()>0&&s.length()<sizeof(wan_ip)){s.toCharArray(wan_ip,sizeof(wan_ip));http.end();return true;}}
  http.end();return false;
}
static void updateWanIPIfNeeded(){
  if(WiFi.status()!=WL_CONNECTED) return;
  uint32_t now=millis(); bool haveWan=(strcmp(wan_ip,"N/A")!=0);
  if(haveWan&&now-lastWanFetch<600000) return;
  if(!haveWan&&now-lastWanFetch<5000) return;
  if(fetchWANIPOnce("http://api.ipify.org")||fetchWANIPOnce("http://ifconfig.me/ip"))
    lastWanFetch=now; else lastWanFetch=now;
}
static void WiFiEvent(WiFiEvent_t event){
  if(event==ARDUINO_EVENT_WIFI_STA_DISCONNECTED){wifiReconnects++;strncpy(wan_ip,"N/A",sizeof(wan_ip));}
  else if(event==ARDUINO_EVENT_WIFI_STA_GOT_IP){strncpy(wan_ip,"N/A",sizeof(wan_ip));}
}

/* ===================【 BLE Data Parsing and Callback 】=================== */
static bool extractFDCD(const std::vector<uint8_t>& adv, std::vector<uint8_t>& out){
  size_t i=0;
  while(i+1<adv.size()){
    uint8_t len=adv[i]; if(len==0) break;
    if(i+1+len>adv.size()) break;
    if(adv[i+1]==0x16 && len>=3 && adv[i+2]==0xCD && adv[i+3]==0xFD){
      out.assign(adv.begin()+i+4, adv.begin()+i+1+len);
      return true;
    }
    i+=1+len;
  }
  return false;
}
static bool parseFDCD_TLV(const std::vector<uint8_t>& sd, QingpingParsed&o){
  if(sd.size()<14) return false;
  size_t pos=8;
  auto rd16s=[&](size_t off){return (int16_t)(sd[off]|(sd[off+1]<<8));};
  auto rd16u=[&](size_t off){return (uint16_t)(sd[off]|(sd[off+1]<<8));};
  pos+=2;
  int16_t t_raw=rd16s(pos); pos+=2;
  uint16_t h_raw=rd16u(pos); pos+=2;
  o.temperature_c=t_raw/10.0f;
  o.humidity_rh=h_raw/10.0f;
  o.battery_pct=-1; float kpa=NAN;
  while(pos+1<sd.size()){
    uint8_t tag=sd[pos++],len=sd[pos++];
    if(pos+len>sd.size()) break;
    if(tag==0x02&&len==1) o.battery_pct=sd[pos];
    else if(tag==0x07&&len==2) kpa=rd16u(pos)/100.0f;
    pos+=len;
  }
  if(isnan(kpa)) return false;
  o.pressure_kpa=kpa; return true;
}
class MyScanCB: public NimBLEScanCallbacks {
  void handle(const NimBLEAdvertisedDevice&dev){
    if(dev.getAddress().toString()!=TARGET_BLE_ADDR) return;
    std::vector<uint8_t>payload(dev.getPayload().begin(),dev.getPayload().end());
    std::vector<uint8_t>fdcd; if(!extractFDCD(payload,fdcd)) return;
    QingpingParsed v{}; if(!parseFDCD_TLV(fdcd,v)) return;
    v.rssi_dbm=dev.getRSSI(); g_last=v; g_haveData=true;
  }
  void onResult(NimBLEAdvertisedDevice*adv){if(adv)handle(*adv);}
  void onResult(const NimBLEAdvertisedDevice*adv){if(adv)handle(*adv);}
};

/* ===================【 LED Control Function 】=================== */
static void setLed(bool on) {
  ledState = on;
  digitalWrite(LED_PIN, on ? LOW : HIGH); // ESP32-C3 LED: LOW=ON, HIGH=OFF
  client.publish(STATE_LED_TOPIC, on ? "ON" : "OFF", true);
}

/* ===================【 MQTT Discovery 】=================== */
static void publishDiscoverySensor(const SensorConfig& s) {
  char topic[160], payload[1024], tpl[96];
  snprintf(topic, sizeof(topic), "%s/sensor/%s_%s/config", discovery_prefix, topic_prefix, s.id);
  snprintf(tpl, sizeof(tpl), "{{ value_json.%s }}", s.id);
  int off = snprintf(payload, sizeof(payload),
    "{"
      "\"name\":\"%s\",\"has_entity_name\":true,"
      "\"unique_id\":\"%s_%s\",\"state_topic\":\"%s/state\","
      "\"availability_topic\":\"%s\",\"icon\":\"%s\",\"value_template\":\"%s\"",
      s.name, DEVICE_ID, s.id, topic_prefix, AVAIL_TOPIC, s.icon, tpl
  );
  if (*s.unit)       off += snprintf(payload+off, sizeof(payload)-off, ",\"unit_of_measurement\":\"%s\"", s.unit);
  if (*s.devclass)   off += snprintf(payload+off, sizeof(payload)-off, ",\"device_class\":\"%s\"", s.devclass);
  if (*s.stateclass) off += snprintf(payload+off, sizeof(payload)-off, ",\"state_class\":\"%s\"", s.stateclass);
  if (s.category)    off += snprintf(payload+off, sizeof(payload)-off, ",\"entity_category\":\"%s\"", s.category);
  snprintf(payload+off, sizeof(payload)-off,
    ",\"device\":{\"identifiers\":[\"%s\"],\"name\":\"%s\",\"model\":\"%s\",\"manufacturer\":\"%s\",\"sw_version\":\"%s\",\"hw_version\":\"%s\"}}",
    DEVICE_ID, DEVICE_NAME, DEVICE_MODEL, DEVICE_MANUFACTURER, SW_VERSION, HW_VERSION
  );
  client.publish(topic, payload, true);
  delay(30);
}
static void publishDiscoveryRestartButton() {
  char topic[200], payload[512];
  snprintf(topic,sizeof(topic), "%s/button/%s_restart/config", discovery_prefix, topic_prefix);
  snprintf(payload,sizeof(payload),
    "{\"name\":\"Restart\",\"unique_id\":\"%s_restart\",\"command_topic\":\"%s\","
    "\"availability_topic\":\"%s\",\"icon\":\"mdi:restart\","
    "\"device\":{\"identifiers\":[\"%s\"],\"name\":\"%s\",\"model\":\"%s\",\"manufacturer\":\"%s\",\"sw_version\":\"%s\",\"hw_version\":\"%s\"}}",
    DEVICE_ID,CMD_RESTART_TOPIC,AVAIL_TOPIC,DEVICE_ID,DEVICE_NAME,DEVICE_MODEL,DEVICE_MANUFACTURER,SW_VERSION,HW_VERSION);
  client.publish(topic,payload,true); delay(20);
}
static void publishDiscoveryLedSwitch() {
  char topic[200], payload[512];
  snprintf(topic,sizeof(topic), "%s/switch/%s_led/config", discovery_prefix, topic_prefix);
  snprintf(payload,sizeof(payload),
    "{"
      "\"name\":\"on-board LED\","
      "\"unique_id\":\"%s_led\","
      "\"command_topic\":\"%s\","
      "\"state_topic\":\"%s\","
      "\"availability_topic\":\"%s\","
      "\"icon\":\"mdi:led-on\","
      "\"optimistic\":false"
      /* Important: Do not set "retain": true here, or HA will send retained commands to command_topic */
      ",\"device\":{\"identifiers\":[\"%s\"],\"name\":\"%s\",\"model\":\"%s\",\"manufacturer\":\"%s\",\"sw_version\":\"%s\",\"hw_version\":\"%s\"}"
    "}",
    DEVICE_ID, CMD_LED_TOPIC, STATE_LED_TOPIC, AVAIL_TOPIC,
    DEVICE_ID, DEVICE_NAME, DEVICE_MODEL, DEVICE_MANUFACTURER, SW_VERSION, HW_VERSION);
  client.publish(topic, payload, true);
  delay(20);
}
static void publishAllDiscovery(){
  for(const auto&s:sensors) publishDiscoverySensor(s);
  publishDiscoveryRestartButton();
  publishDiscoveryLedSwitch();
}

/* ===================【 MQTT Publish State 】=================== */
static void publishState(){
  if(!g_haveData) return;
  StaticJsonDocument<1024>doc;
  doc["temperature"]=g_last.temperature_c;
  doc["humidity"]=g_last.humidity_rh;
  doc["battery"]=g_last.battery_pct;
  doc["pressure"]=g_last.pressure_kpa;
  doc["rssi"]=g_last.rssi_dbm;
  doc["boot_count"]=bootCount;
  doc["ip"]=(WiFi.status()==WL_CONNECTED)?WiFi.localIP().toString():"0.0.0.0";
  doc["mac"]=WiFi.macAddress();
  doc["mqtt_errors"]=mqttErrors;
  doc["reset_reason"]=resetReasonStr();
  doc["wan_ip"]=wan_ip;
  doc["wifi_bssid"]=(WiFi.status()==WL_CONNECTED)?WiFi.BSSIDstr():"N/A";
  doc["wifi_channel"]=(WiFi.status()==WL_CONNECTED)?WiFi.channel():0;
  doc["wifi_reconnects"]=wifiReconnects;
  doc["rssi_proxy"]=(WiFi.status()==WL_CONNECTED)?WiFi.RSSI():0;
  doc["wifi_ssid"]=(WiFi.status()==WL_CONNECTED)?WiFi.SSID():"Offline";
  doc["uptime"]=millis()/1000;
  char buf[900];serializeJson(doc,buf,sizeof(buf));
  client.publish((String(topic_prefix)+"/state").c_str(),buf,true);
}

/* ===================【 MQTT Callback / Connection 】=================== */
static void mqttCallback(char*t,byte*pl,unsigned int l){
  if(strcmp(t,CMD_RESTART_TOPIC)==0) g_needRestart=true;
  else if(strcmp(t,CMD_LED_TOPIC)==0) {
    String msg((char*)pl, l);
    msg.toUpperCase();
    if(msg=="ON") setLed(true);
    else if(msg=="OFF") setLed(false);
  }
}
/* ===================【 MQTT Connection Flow 】=================== */
static void reconnect(){
  while(!client.connected()){
    if(client.connect(DEVICE_ID, mqtt_user, mqtt_pass, AVAIL_TOPIC, 0, false, "offline")){
      client.publish(AVAIL_TOPIC, "online", true);

      // Send discovery first (command configs without retain)
      publishAllDiscovery();

      // 1) Clear retained command messages
      client.publish(CMD_LED_TOPIC, "", true);  // Empty string + retain=true clears retained message
      delay(10);

      // 2) Default LED OFF on boot, and report state (state uses retain, so HA syncs OFF on init)
      setLed(false);

      // 3) Subscribe after clearing, to avoid receiving old retained ON
      client.subscribe(CMD_RESTART_TOPIC);
      client.subscribe(CMD_LED_TOPIC);

      // Publish state once after connect
      publishState();
    } else {
      mqttErrors++;
      delay(2000);
    }
  }
}

/* ===================【 Setup / Loop 】=================== */
void setup(){
  Serial.begin(115200);
  prefs.begin("sys",false);
  bootCount=prefs.getUInt("boot",0)+1; prefs.putUInt("boot",bootCount); prefs.end();

  pinMode(LED_PIN, OUTPUT);

  // === Startup LED blink 3 times ===
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED_PIN, LOW);   // ON
    delay(200);
    digitalWrite(LED_PIN, HIGH);  // OFF
    delay(200);
  }
  setLed(false); // After blink → default OFF + MQTT report

  WiFi.onEvent(WiFiEvent);
  WiFi.begin(ssid,password);
  while(WiFi.status()!=WL_CONNECTED){delay(500);Serial.print(".");}
  client.setServer(mqtt_server,mqtt_port);
  client.setBufferSize(MQTT_MAX_PACKET_SIZE);
  client.setCallback(mqttCallback);

  NimBLEDevice::init(""); NimBLEDevice::setPower(ESP_PWR_LVL_P3);
  NimBLEScan*s=NimBLEDevice::getScan(); static MyScanCB cb; s->setScanCallbacks(&cb,true);
  s->setActiveScan(false); s->setDuplicateFilter(false);
  s->setInterval(80); s->setWindow(48); s->start(0,false,true);
}
void loop(){
  updateWanIPIfNeeded();
  if(!client.connected()) reconnect();
  client.loop();
  if(g_needRestart){
    g_needRestart=false;
    client.publish(AVAIL_TOPIC,"rebooting",true);
    client.loop(); delay(150); ESP.restart();
  }
  static unsigned long lastPub=0; unsigned long now=millis();
  if(now-lastPub>=PUBLISH_INTERVAL_MS){lastPub=now;publishState();}
}
